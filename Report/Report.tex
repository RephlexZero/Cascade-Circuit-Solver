\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\begin{document}

\title{Cascade Circuit Analyser Design report\\
{\footnotesize \textsuperscript{*}EE20084 - Structured Programming}
}

\author{\IEEEauthorblockN{Jake Stewart}
\IEEEauthorblockA{\textit{Department of Electrical and Electronic Engineering} \\
\textit{University of Bath}\\
Bath, United Kingdom \\
email: js3910@bath.ac.uk}
}
\maketitle

\begin{abstract}
This document outlines the design approach used to solve the terminal inputs and outputs to a generalised two-port cascade
circuit by method of ABCD matrix analysis. The program is designed to be modular, flexible and robust, with a thorough testing process
embedded.
\end{abstract}

\begin{IEEEkeywords}
circuit analysis, Python, doctest, regex, software testing
\end{IEEEkeywords}

\tableofcontents

\section{Analysis of the Problem}
The main objective of the assignment is to create a program that analyzes 
electrical circuits using two-port ABCD matrix analysis, with functionalities to read an 
input ".net" file, perform the analysis calculations, and output the results in the specified CSV format.

\subsection{Sub-tasks Identification}
\begin{itemize}
    \item Parsing the input file to extract circuit components, terminations, and desired outputs.
    \item Malformed input file handling.
    \item Translating those components into a matrix representation for analysis.
    \item Calculatinng the ABCD matrix for the circuit.
    \item Applying the ABCD matrix to the input and output terminations to obtain the desired results.
    \item Logic error handling and exception raising.
    \item Generating output files with the analysis results.
    \item Extending the program to include additional features such as exponent prefixes and decibel calculations.
\end{itemize}

\section{Module realisation and design decisions}
This section breaks down the program into modules, classes and functions, and explains the design decisions made for each.\\
The program is divided into four modules, each with a specific role:
\begin{itemize}
    \item \texttt{net\_parser.py}: Parses the input file and extracts circuit information.
    \item \texttt{circuit.py}: Contains classes and functions for circuit analysis.
    \item \texttt{csv\_writer.py}: Manages the creation and formatting of the output file with analysis results.
    \item \texttt{main.py}: The main driver script that utilizes the above modules.
\end{itemize}

From a broad view, due to the flexibale nature of the input file, the program is designed to be modular and flexible in kind. The circuit module is
designed as a class and subclass structure, with the main Circuit class containing the component array, the source and load terminations, and the output array.
The subclasses are instances of the components, terminations, and output variables which are then appended to their respective arrays to keep track of their order.
The main class has the methods to add to and sort these arrays, and to recusively reduce and invert the component matricies to obtain the ABCD termination solutions.
\\\\
The ordering of output array is then used to generate the output CSV, and it is formatted to match the provided example output files. 

\subsection{Data Structures}
This section outlines the primary data structures utilized within the main module (\texttt{main.py}), the circuit analysis module (\texttt{circuit.py}), and other modules such as the net file parser (\texttt{net\_parser.py}) and the CSV writer (\texttt{csv\_writer.py}).

\subsubsection*{Main Module (\texttt{main.py})}
The main module orchestrates the program's execution flow, leveraging the following data structures:
\begin{itemize}
    \item \textbf{Circuit Object:} An instance of the \texttt{Circuit} class from \texttt{circuit.py}, encapsulating the entire circuit's structure, including components and terminations.
    \item \textbf{Results array:} A list for the circuit's subclass of solved terminations for CSV output. 
\end{itemize}

\subsubsection*{Circuit Analysis Module (\texttt{circuit.py})}
Central to circuit analysis, this module employs:
\begin{itemize}
    \item \textbf{Circuit Class:} Contains the circuit's comprehensive data, with arrays for instances of the component, termination, and output subclasses.
    \begin{itemize}
        \item \textbf{Component List:} A list of component objects (resistors, capacitors, etc.), detailing type, value, and connections (e.g. \{\texttt{"n1"}: 1, \texttt{"n2"}: 2, \texttt{"value"}: 100, \texttt{"type"}: "R"\}).
        \item \textbf{Terminations Dictionary:} Stores the source and load terminations parameters (e.g., \{\texttt{"VT"}: 5, \texttt{"RS"}: 50\}).
        \item \textbf{Output Requirements List:} Lists the output variables as defined in the input file's order (e.g. \{\texttt{"name"}: Vin, \texttt{"unit"}: V, \texttt{"magnitude"}: m, \texttt{"is\_db"}: true\}).
    \end{itemize}
    \item \textbf{NumPy Arrays:} Employed for constructing and manipulating ABCD matrices, facilitating the numerical analysis of the electrical circuits. These arrays provide efficient handling of complex numbers and matrix operations essential for ABCD matrix calculations.
\end{itemize}

\subsubsection*{Net File Parser Module (\texttt{net\_parser.py})}
Responsible for interpreting the circuit definition file, it utilizes:
\begin{itemize}
    \item \textbf{Regular Expressions (Regex):} For identifying component definitions and extracting pertinent information. 
    This is especially useful as it can allow for optional fields,flexible use of whitespace and has extremely robust pattern matching,
    this also lets us define the correct form of a line for each section in the input file, playing nicely into exception raising when a line doesn't get a match.
    \item \textbf{Lists and Dictionaries:} To organize components, terminations, and output specifications for subsequent processing.
\end{itemize}

\subsubsection*{CSV Writer Module (\texttt{csv\_writer.py})}
Manages output file creation, employing:
\begin{itemize}
    \item \textbf{Lists:} To compile analysis results for output variables across specified frequencies.
    \item \textbf{File Handler:} A standard object for writing formatted results to a CSV file/tempfile.
    \item \textbf{Magnitude Lookup:} A dictionary of magnitude multipliers for converting results to the desired units (e.g., \texttt{"m"}: 1e-3, \texttt{"u"}: 1e-6).
\end{itemize}

\subsection{Functions and methods overview}
This section provides an overview of the primary functions and methods within the program's modules, detailing their purpose and functionality.

\subsection*{Input File Parsing}
The parsing of the input file is a critical initial step for the circuit analysis program,
 involving several key tasks to correctly interpret or sanatise the provided data for circuit components,
  terminations, and desired outputs. The process is outlined as follows:

\begin{enumerate}
    \item \textbf{Reading the File:} Open and read the contents of the '.net' file line-by-line, paying special attention to lines starting with the hash symbol (\#) as comments and thus skipping them during processing.
    \item \textbf{Identifying Blocks:} Systematically identify the three main blocks within the file: CIRCUIT, TERMS, and OUTPUT, each of which provides essential data for the circuit analysis.
    \item \textbf{Extracting Component Data:} Within the CIRCUIT block, extract details of each component, including node connections and component values (resistance, inductance, capacitance, or conductance).
    \item \textbf{Source and Load Termination:} From the TERMS block, determine the terminal connections provided for the source and load terminations, along with their respective values if available.
    \item \textbf{Output Requirements:} In the OUTPUT block, capture the required output variables and formats, ensuring the program knows what results to calculate and how to format them.
    \item \textbf{Error Handling:} Implement robust error handling to manage potential issues in the input file, such as missing/duplicate blocks, incorrect formatting, or unsupported component types/values.
    \item \textbf{Pattern Matching:} Utilize regular expressions to identify and extract the required data from the input file, to help with resilience and flexibility in handling different input file formats.\\
    This requires that the cases where the output is in decibels or inputs/outputs with exponent prefixes are handled and stored for the extension tasks.
    \item \textbf{Storing Data:} Efficiently store the extracted information in the Circuit class module, to the respective component, termination, and output sub-classes.
\end{enumerate}

This structured approach ensures that the program can flexibly interpret and process the wide range of circuit definitions it may encounter.

\subsection*{Circuit Realization and Solving}
To realize and solve the electrical circuit defined in the input file, a systematic approach towards constructing and analyzing the circuit using the ABCD matrix method is as follows:

\begin{enumerate}
    \item \textbf{Circuit Representation:} Construct an internal representation of the circuit from the parsed data, an array of component objects, and the source and load terminations. This can then be sorted based on the node connections to facilitate the ABCD matrix construction.
    \item \textbf{Matrix Construction:} Implement functions to calculate the ABCD matrices for individual circuit elements (resistors, inductors, capacitors, and any series or parallel combinations thereof).
    \item \textbf{Cascade Handling:} A method to create a new array of 2x2 sub-ABCD matricies from the components object array, allowing for the multiplication reduction down to an individual ABCD matrix to represent the entire circuit's behavior.
    \item \textbf{Termination Analysis:} Apply the source and load terminations as defined in the TERMS block to the overall circuit matrix to determine input/output impedance and thus Vin, Iin, Vout, and Iout.
    This requires that there are different methods for if the source is of Thevenin or Norton type to determine Vin/Iin.
    \item \textbf{Solving the Circuit:} Utilize the inversion of the ABCD matrix of the whole circuit to solve for the desired output variables such as input/output impedance, voltage gain, and power gain.
    \item \textbf{Error and Exception Handling:} Implement comprehensive error checking and exception handling to print an empty output file with an error message if the circuit analysis fails at any stage.
    \item \textbf{Result storage:} Repeat the above and store the results for each frequency iteration in an array, to be passed to the CSV writer for output file generation.
\end{enumerate}

\subsection*{Output File Generation}
The final step in the program is to generate the output file with the calculated results. This involves the following steps:

\begin{enumerate}
    \item \textbf{CSV File Creation:} Create a new CSV file with the specified output filename and write the header row with the required output variables names and units.\\
    This also requires that the cases where the output is in decibels or with exponent prefixes are handled, and that the order of the headers matches the output array order.
    \item \textbf{Data Writing:} Write the calculated results to the CSV file, ensuring the order (as specified in the OUTPUT block and stored in the output array), 
    and the formatting (decibels, exponent prefixes) in scientific notation, are correctly applied.
    \item \textbf{File formatting:} Improve the readability of the file by padding the columns to be equal widths and aligning the values to one side, matching the provided example output files.\\
    This function should be able to operate on any CSV file.
    \item \textbf{Error Handling:} Implement error handling to write an empty output file with an error message if the output file generation fails at any stage.
\end{enumerate}

\subsection*{Extension Tasks}
All of the extension tasks rely on the input file parsing being versatile enough to encompass the 
additional features, the approach to if the output is in dB or has additional exponent prefixes will be to store that to the output 
array and then convert the results to dB + Phase in the CSV writer and/or apply the exponent prefix.

 Similar to determining if the source is of Thevenin or Norton type, the program will need to differentiate between if the frequency sweep is linear or logarithmic,
 which can also be done with a simple check of which sufficient values were provided by the input.\\

As for input values, the exponent will be converted on the spot with the input parser, this means that internally, all calculations are standardised to the base unit for consistency.

For all the above tasks, the input parser will pick them all up with regular expressions, these parameters being optional and the program will be able to handle them if they are present or not.
\section{Testing Methodology}

Testing is an integral part of the development process, ensuring that each component of the program functions correctly and as expected. For this project, testing is focused on ensuring the accuracy and reliability of the electrical circuit analysis program, particularly in the calculation functions and input file parsing. The methodology employs a combination of Python doctests for function-level testing and manual testing with modified input files for regex and error handling validation.

\subsection{Python Doctests}
Doctests are a convenient way to embed tests in the documentation strings (docstrings) of Python functions. They are ideal for testing individual functions, especially those involved in calculations, data manipulation, and specific logic implementations. Important functions within modules like \texttt{circuit.py} and \texttt{net\_parser.py} will be tested to confirm their correctness. For instance:

\begin{itemize}
    \item In \texttt{circuit.py}, doctests will validate the ABCD matrix calculations for different circuit components, ensuring that the matrix operations produce the expected outcomes.
    \item In \texttt{net\_parser.py}, doctests will test the component parsing logic, ensuring that circuit components are accurately extracted from input strings.
\end{itemize}

These tests are executed automatically as part of the documentation review process, offering a quick and integrated way to validate function outputs against expected results.

\subsection{Regex and Error Handling Testing}
For regex testing and error handling, a manual approach is adopted due to the complexity and variability of input files. This involves creating a set of modified example input files that specifically target edge cases, malformed inputs, and unusual component arrangements. The aim is to:

\begin{itemize}
    \item Ensure that the regex patterns correctly match and extract component information, even in the presence of variations in spacing, line endings, and format deviations.
    \item Validate that the program can gracefully handle errors in the input file, such as missing blocks, unsupported component types, or incorrect formatting, by raising appropriate exceptions or producing meaningful error messages.
\end{itemize}

This manual testing approach is crucial for assessing the robustness and reliability of the input parsing and error handling mechanisms of the program.\\

Besides the testing, edge cases will be handled with exception raising, and the program will be able to handle any input file that is in the correct format, and will raise an exception if it is not thanks to the regex, but also functions will
have checks against invalid inputs, such as negative or zero frequencies, partially defined sources and will raise exceptions if these are encountered.

\section{Conclusion}
The combination of doctests and manual testing provides a comprehensive testing strategy that
 covers both function-level correctness and the overall robustness of the 
 program against malformed or unexpected inputs. By ensuring that each component 
 functions as expected and that the program can handle errors gracefully, this 
 testing methodology supports the development of a reliable and accurate
  electrical circuit analysis tool.
\end{document}